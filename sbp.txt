== CLIENT NOTES ==

Fetch data id and keySalt/folderKey only on page load, use them only from memory, but keep writing to them on every folder navigation.
This way the user can use it sb from multiple tabs

===



baseKey - something something argon2

accountId = hmac(baseKey, accSalt)
masterKey = hmac(baseKey, keySalt)
baseDataId = hmac(baseKey, baseDataIdSalt)
baseFolderKey = hmac(baseKey, baseFolderKeySalt)

getSession(accountId, useIpBasedSession) - from server
	-- useIpBasedSession is an opt out feature that lets the user specify whether to lock the session to ip. This is useful when the user wants to use anonymizing tools that frequently change their ip.
	
	sessionValue = expireDate + rand 8 bytes + accountId
	if(useIpBasedSession)
		innerSessionKey = hmac(ipSessionKey, ip)
	else
		innerSessionKey = staticSessionKey
	
	return enc(useIpBasedSession (as 1 byte) + enc(sessionValue, innerSessionKey), outerSessionKey)

_deriveSessionKey()
	return hmac(derivedKeyBase + accountId + ip ? useIpBasedSession, rand_long)


setCookie(enc(accountId, session.key)) - HttpOnly (so by server)

innerMasterKeyDecryptionKey = randKey()
outerMasterKeyDecryptionKey = randKey()

setCookie(enc(innerMasterKeyDecryptionKey, outerMasterKeyDecryptionKey))
setLocal(outerMasterKeyDecryptionKey)
setLocal(enc(enc(masterKey + dataId + folderKey, session.key), innerMasterKeyDecryptionKey))


dataId - 16 bytes
metadata - 1 byte to denote whether its a file or folder + 16 bytes of random data used to derive encryption key + var length name
	max length is 240 bytes, including padding. meaning the max length metadata can be is 207 bytes
fileId - 16 bytes

folder content - dataId + folderKeySalt (16 bytes)

folderKey = hmac(masterKey + folderDataId, folderKeySalt)

metadataEncryptionKey = hmac(folderKey, fileId)
encryptionKey - hmac(folderKey, fileRand)

makefile(data_id, metadata, file_size)
	returns 0+file_id on success, 1 byte code+message on failure

	file_id - hmac(data_id + (initial) meta_data + rand + account_id, secret)
	file_on_disk - hmac(file_id + file_size, hmac(account_id, secret))
	^ when cleaning account or data id, just get a list of all the needed files, calculate hashes, delete the files and then the rows
	(dont store on db)

upload_content(fileId, fileSize, filePointer, data)
	returns 0 if everything went well, otherwise 1 byte code with the error message directly appended to it

	When sending a block of data file_size and file_id should be provided.
	When storing the files on the server no requests to the DB should be made.
	file_size is used to check if filePointer + data.Length is within the allowed range [0, file_size)

upload_finished(fileid)
	-- When makefile is used, the file is created in an incomplete state and cant be downloaded. --

	Once all the data has been uploaded, this gets called.

	An incomplete file should still be returned by the list api and shown to the user as "Not Complete", along with how much data its taking up on disk (as "disk/reserved") -- and the option to delete it. --

	All the regular file interactions should remain, however, when the user attempts to download it they should be warned that the file is incomplete and that continuining might result in a corrupted file. The user should be given the option to either download the file in encrypted form (and potentially, if I have the time, a page to locally attempt decrypting it) or to attempt decrypting it. Incomplete files should be downloaded up to the point they were reported to be uploaded to when the file list api was invoked and decrypted with the NoPadding setting (since only the final block will have the PKCS7 padding).
	



