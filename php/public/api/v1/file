<?php
	require_once($_SERVER["DOCUMENT_ROOT"] . "/../lib/utility.php");
	require_once($_SERVER["DOCUMENT_ROOT"] . "/../lib/session.php");
	require_once($_SERVER["DOCUMENT_ROOT"] . "/../lib/file_manager.php");

	RouteSetup();

	$min_header_size = 1 + 1 + 6 + 8 + 8 + 104 + 16 + 1; // includes one byte of file_data, since its variable size
	$max_header_size = ($min_header_size - 1) + 512;

	$read_chunk_size = 10_000_000;

	switch($_SERVER["REQUEST_METHOD"])
	{
		case "GET":
			$session = HandleSession();

			$data_id = GetHeader("sb-data-id");
			if($data_id === null)
				ExitResponse(
					ResponseType::MissingArgument,
					"sb-data-id not provided"
				);

			$data_id = base64_decode($data_id, true);
			if($data_id === false)
				ExitResponse(
					ResponseType::BadArgument,
					"sb-data-id is invalid"
				);


			$db = new FileDatabase();
			ExitResponse(ResponseType::Success, pack("Qa*", $read_chunk_size, json_encode($db->ListFiles($session->account_id, $data_id)))); // chunk size + list

		case "POST":
			$session = HandleSession();

			if(!isset($_FILES["file"]))
				ExitResponse(
					ResponseType::MissingArgument,
					"file not provided"
				);

			if($_FILES["file"]["size"] < $min_header_size)
				ExitResponse(
					ResponseType::BadArgument,
					"file too small"
				);

			$meta_header_size = GetHeader("sb-header-size");
			if($meta_header_size === null)
				ExitResponse(
					ResponseType::MissingArgument,
					"sb-header-size not provided"
				);

			$meta_header_size = intval($meta_header_size);
			if($meta_header_size < $min_header_size)
				ExitResponse(
					ResponseType::BadArgument,
					"sb-header-size too small"
				);

			if($meta_header_size > $max_header_size)
				ExitResponse(
					ResponseType::BadArgument,
					"sb-header-size too large"
				);

			if($_FILES["file"]["size"] < $meta_header_size)
				ExitResponse(
					ResponseType::BadArgument,
					"sb-header-size is invalid"
				);

			$file_name = $_FILES["file"]["tmp_name"];
			$recv_file_handle = fopen($file_name, "rb");
			
			$file_header = new FileHeader(fread($recv_file_handle, $meta_header_size));
			$file_name = $file_header->DeriveFileName($session->account_id);

			$file_exists = file_exists($file_name);

			switch ($file_header->action)
			{
				case 0:	// get
					if($file_exists)
						ExitResponse(ResponseType::BadArgument, "file not found");

					ExitResponse(ResponseType::Success, file_get_contents(
						$file_name,
						false, null,
						$file_header->offset,
						$read_chunk_size
					));

				case 1: // send
					if(!$file_exists || $file_header->finished === true)
					{
						$db = new FileDatabase();

						if(!$file_exists)
						{
							if(!$db->TryReserveSpace($session->account_id, $file_header->file_size))
							{
								if(!$db->AccountExists($session->account_id)) // realistically this check should be done on session creation, but that has a higher chance of abuse than here
								{
									$db->CreateAccount($session->account_id);
									if(!$db->TryReserveSpace($session->account_id, $file_header->file_size)) // TODO: make this count the size of the DB row					
										ExitResponse(ResponseType::FileAllocationFailed);
								}
								else
									ExitResponse(ResponseType::FileAllocationFailed);
							}

							if(!$db->RegisterFile($session->account_id, $file_header->data_id, $file_header->file_data, $file_header->encryption_data, $file_header->file_size))
								ExitResponse(ResponseType::ServerError, CreateSecureResponseData("failed to register file"));
						}
					}

					$file_content = fread($recv_file_handle, $_FILES["file"]["size"]);
					if($file_header->offset + ($_FILES["file"]["size"] - $meta_header_size) > $file_header->file_size)
						ExitResponse(ResponseType::BadArgument, "attempting to write beyond file bounds");

					$write_file_handle = fopen($file_name, "cb");
					fseek($write_file_handle, $file_header->offset);
					fwrite($write_file_handle, $file_content);

					if($file_header->finished === true)
						$db->FinishFileUpload($session->account_id, $file_header->data_id, $file_header->file_data, $file_header->encryption_data, $file_header->file_size); // $db created above

					ExitResponse(ResponseType::Success);
				case 2: // delete
					if($file_exists && unlink($file_name) === false) // maybe the file doesnt exist, while for whatever reason the listing in the db might
						ExitResponse(ResponseType::ServerError, "failed to delete file", true);
					
					$db = new FileDatabase();

					if($db->UnregisterFile($session->account_id, $file_header->data_id, $file_header->file_data, $file_header->encryption_data, $file_header->file_size) === false)
						ExitResponse(ResponseType::ServerError, "failed to unregister file", true);

					if($db->TryReserveSpace($session->account_id, -$file_header->file_size) === false) // eventually, in the clean up function, add a check if the file size differs froms the sum of the registered file sizes
						ExitResponse(ResponseType::ServerError, "failed to unreserve space", true);
					
				default:
					ExitResponse(ResponseType::BadArgument, "bad action given");

			}

		default:
			ExitResponse(ResponseType::BadRequestMethod);
	}
?>